<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveGeneric #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE ImportQualifiedPost #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE MultiParamTypeClasses #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE QuasiQuotes #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Constrained.Examples.CheatSheet</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier">Data.Set</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier">Set</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier">Data.Set</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Set</span></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier">GHC.Generics</span></a></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-identifier">Test.QuickCheck</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-identifier">Property</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-keyword">label</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Constrained.html"><span class="hs-identifier">Constrained</span></a></span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="hs-comment">-- The `constrained-generators` library allows us to write</span><span>
</span><span id="line-20"></span><span class="hs-comment">-- constraints that give us random generators, shrinkers, and checkers</span><span>
</span><span id="line-21"></span><span class="hs-comment">-- for data using a small embedded DSL, which defines a limited first order logic.</span><span>
</span><span id="line-22"></span><span class="hs-comment">--</span><span>
</span><span id="line-23"></span><span class="hs-comment">-- Every first order logic has 4 parts, as does our DSL.</span><span>
</span><span id="line-24"></span><span class="hs-comment">-- 1) Terms :  e.g. x, 5, (member_ x set) (x ==. y)</span><span>
</span><span id="line-25"></span><span class="hs-comment">--    Implemented as (Term fn a). We have variables like 'x', and constants like '5'.</span><span>
</span><span id="line-26"></span><span class="hs-comment">--    'member_' and '==.' are function symbols, and build Terms from other terms.</span><span>
</span><span id="line-27"></span><span class="hs-comment">--    By convention, a name followed by '_' or an infix operator followed by '.' are function symbols.</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- 2) Predicates (over terms). Predicates commonly used are</span><span>
</span><span id="line-29"></span><span class="hs-comment">--        TruePred,</span><span>
</span><span id="line-30"></span><span class="hs-comment">--        FalsePred (pure &quot;explain&quot;),</span><span>
</span><span id="line-31"></span><span class="hs-comment">--        assert $ termWithTypeBool,</span><span>
</span><span id="line-32"></span><span class="hs-comment">--    Some more unusual predicates are described below.</span><span>
</span><span id="line-33"></span><span class="hs-comment">--    Implemented as type (Pred fn)</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- 3) Combinators (combining predicates). In general, And, Or, Not, Implies, True, False</span><span>
</span><span id="line-35"></span><span class="hs-comment">--    But in the DSL, we are limited to</span><span>
</span><span id="line-36"></span><span class="hs-comment">--      'And' using Block :: [Pred] -&gt; Pred</span><span>
</span><span id="line-37"></span><span class="hs-comment">--      'Not' using the function symbol not_ :: Term fn Bool -&gt; Term fn Bool</span><span>
</span><span id="line-38"></span><span class="hs-comment">--            for example:  assert $ not_ (x ==. y)</span><span>
</span><span id="line-39"></span><span class="hs-comment">--      limited form of 'Or' using</span><span>
</span><span id="line-40"></span><span class="hs-comment">--         chooseSpec :: (Int, Specification fn a)- &gt; (Int, Specification fn a) -&gt; Specification fn a</span><span>
</span><span id="line-41"></span><span class="hs-comment">-- 4) Quantifiers (applying constraints to many things) :</span><span>
</span><span id="line-42"></span><span class="hs-comment">--    forAll: Term fn t -&gt; (Term fn a -&gt; p) -&gt; Pred fn</span><span>
</span><span id="line-43"></span><span class="hs-comment">--    exists: ((forall b. Term fn b -&gt; b) -&gt; GE a) -&gt; (Term fn a -&gt; p) -&gt; Pred fn</span><span>
</span><span id="line-44"></span><span class="hs-comment">--    These are explained in detail below</span><span>
</span><span id="line-45"></span><span>
</span><span id="line-46"></span><span class="hs-comment">-- In case you are interested, here is a list of supported function symbols (note the use of the '_' and '.' convention)</span><span>
</span><span id="line-47"></span><span class="hs-comment">-- disjoint_,  dom_,  elem_,  length_,  member_,  not_,  rng_,  singleton_,  sizeOf_,  subset_,  sum_,  (/=.),</span><span>
</span><span id="line-48"></span><span class="hs-comment">-- (&lt;.),  (&lt;=.),  (==.),  (&gt;.),  (&gt;=.), fromList_, null_, union_</span><span>
</span><span id="line-49"></span><span class="hs-comment">-- You may also use the methods of Num (+) (-) (*), since there is a (Num (Term fn)) instance.</span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span class="hs-comment">-- The first order logic DSL is used to build Specifications</span><span>
</span><span id="line-52"></span><span class="hs-comment">-- A specifcation with type (Specification fn x) has two uses</span><span>
</span><span id="line-53"></span><span class="hs-comment">-- 1) To generate a random values of type 'x', subject to the constraints in the specifications definition.</span><span>
</span><span id="line-54"></span><span class="hs-comment">--    This is implemented by   genFromSpec :: Specification fn x -&gt; Gen x (Gen is the QuickCheck Gen)</span><span>
</span><span id="line-55"></span><span class="hs-comment">-- 2) To test if a value of type 'x' meets all of the constraints given in the specifications definition.</span><span>
</span><span id="line-56"></span><span class="hs-comment">--     This is implemented by  conformsToSpec :: HasSpec fn a =&gt; a -&gt; Specification fn a -&gt; Bool</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-comment">-- Lets get started. We can talk about numbers:</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specInt"><span class="hs-identifier hs-type">specInt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-61"></span><span id="specInt"><span class="annot"><span class="annottext">specInt :: Specification BaseFn Int
</span><a href="Constrained.Examples.CheatSheet.html#specInt"><span class="hs-identifier hs-var hs-var">specInt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872858"><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872858"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872858"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-63"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872858"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span class="hs-comment">-- What's going on here? In short:</span><span>
</span><span id="line-67"></span><span class="hs-comment">--    `constrained :: (HasSpec fn a, IsPred p fn) =&gt; (Term fn a -&gt; p) -&gt; Specification fn a`</span><span>
</span><span id="line-68"></span><span class="hs-comment">--    Introduces the variable `i` over which we can write constraints of type `p` over something</span><span>
</span><span id="line-69"></span><span class="hs-comment">--    of type `a` to produce a `Specifcation fn a` using a list of</span><span>
</span><span id="line-70"></span><span class="hs-comment">--    `assert :: Term fn Bool -&gt; Pred fn` with `Term fn`-level versions (function symbols) of familiar functions like</span><span>
</span><span id="line-71"></span><span class="hs-comment">--    `(&lt;.) :: OrdLike fn a =&gt; Term fn a -&gt; Term fn a -&gt; Term fn Bool`, `null_ :: Term fn [a] -&gt; Term fn Bool`,</span><span>
</span><span id="line-72"></span><span class="hs-comment">--    `rng_ :: (HasSpec fn k, HasSpec fn v, Ord k) =&gt; Term fn (Map k v) -&gt; Term fn (Set k)` etc.</span><span>
</span><span id="line-73"></span><span class="hs-comment">-- We get a generator from `genFromSpec :: Specification BaseFn a -&gt; Gen a`:</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec specInt</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-76"></span><span class="hs-comment">-- 5</span><span>
</span><span id="line-77"></span><span class="hs-comment">-- 6</span><span>
</span><span id="line-78"></span><span class="hs-comment">-- 6</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- 8</span><span>
</span><span id="line-80"></span><span class="hs-comment">-- 5</span><span>
</span><span id="line-81"></span><span class="hs-comment">-- 3</span><span>
</span><span id="line-82"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-83"></span><span class="hs-comment">-- 1</span><span>
</span><span id="line-84"></span><span class="hs-comment">-- 4</span><span>
</span><span id="line-85"></span><span class="hs-comment">-- 8</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-comment">-- Likewise, `shrinkWithSpec :: Specification BaseFn a -&gt; a -&gt; [a]` gives us</span><span>
</span><span id="line-88"></span><span class="hs-comment">-- a shrinker:</span><span>
</span><span id="line-89"></span><span class="hs-comment">-- &#955;&gt; shrinkWithSpec specInt 10</span><span>
</span><span id="line-90"></span><span class="hs-comment">-- [5,8,9]</span><span>
</span><span id="line-91"></span><span class="hs-comment">-- &#955;&gt; shrinkWithSpec specInt 5</span><span>
</span><span id="line-92"></span><span class="hs-comment">-- [3,4]</span><span>
</span><span id="line-93"></span><span class="hs-comment">-- &#955;&gt; shrinkWithSpec specInt 3</span><span>
</span><span id="line-94"></span><span class="hs-comment">-- [2]</span><span>
</span><span id="line-95"></span><span class="hs-comment">-- &#955;&gt; shrinkWithSpec specInt 1</span><span>
</span><span id="line-96"></span><span class="hs-comment">-- []</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-comment">-- And, `conformsToSpec :: a -&gt; Specification BaseFn a -&gt; Bool` gives us a checker:</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- &#955;&gt; 10 `conformsToSpec` specInt</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- False</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- &#955;&gt; 5 `conformsToSpec` specInt</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- True</span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-comment">-- Note that the type of `constrained` says the binding function of type `Term fn a -&gt; p` doesn't</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- have to produce a `Pred fn` (which is the return type of `assert`), but can produce something of type `p`</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- that satisfies `IsPred p fn`. This basically just means something that can be readily turned into a</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- `Pred fn`, like e.g. `Pred fn`, `Bool`, `Term fn Bool`, `[p]` for `IsPred p fn`. Consequently, we could</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- have written `specInt` as:</span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specInt%27"><span class="hs-identifier hs-type">specInt'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-111"></span><span id="specInt%27"><span class="annot"><span class="annottext">specInt' :: Specification BaseFn Int
</span><a href="Constrained.Examples.CheatSheet.html#specInt%27"><span class="hs-identifier hs-var hs-var">specInt'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872854"><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872854"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872854"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn Int
</span><a href="#local-6989586621679872854"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-115"></span><span>
</span><span id="line-116"></span><span class="hs-comment">-- However, beware that when we start mixing `Term fn Bool` and `Pred fn` in these lists we can end</span><span>
</span><span id="line-117"></span><span class="hs-comment">-- up getting some inscrutable error messages. So, if a call to `constrained` or another function that</span><span>
</span><span id="line-118"></span><span class="hs-comment">-- has `IsPred` as a constraint, starts giving you strange error messages, double check that you have</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- used `assert` instead of raw `Term fn Bool` everywhere relevant.</span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-comment">-- We also have support for product types with functions like `fst_`, `snd_`, and `pair_`:</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specProd"><span class="hs-identifier hs-type">specProd</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span id="specProd"><span class="annot"><span class="annottext">specProd :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#specProd"><span class="hs-identifier hs-var hs-var">specProd</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872852"><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872852"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-125"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn (a, b) -&gt; Term fn a
</span><a href="Constrained.Spec.Generics.html#fst_"><span class="hs-identifier hs-var">fst_</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872852"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-126"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn (a, b) -&gt; Term fn b
</span><a href="Constrained.Spec.Generics.html#snd_"><span class="hs-identifier hs-var">snd_</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872852"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">100</span></span><span>
</span><span id="line-127"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span class="hs-comment">-- However, product types can also be a bit finicky:</span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specProd0"><span class="hs-identifier hs-type">specProd0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-132"></span><span id="specProd0"><span class="annot"><span class="annottext">specProd0 :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#specProd0"><span class="hs-identifier hs-var hs-var">specProd0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872848"><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872848"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn (a, b) -&gt; Term fn a
</span><a href="Constrained.Spec.Generics.html#fst_"><span class="hs-identifier hs-var">fst_</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872848"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn (a, b) -&gt; Term fn b
</span><a href="Constrained.Spec.Generics.html#snd_"><span class="hs-identifier hs-var">snd_</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872848"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec specProd0</span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="hs-comment">-- *** Exception: Simplifying:</span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-comment">--   constrained $ \ v0 -&gt; assert $ Less (Fst (ToGeneric v0)) (Snd (ToGeneric v0))</span><span>
</span><span id="line-139"></span><span class="hs-comment">-- optimisePred =&gt; assert $ Less (Fst (ToGeneric v0)) (Snd (ToGeneric v0))</span><span>
</span><span id="line-140"></span><span class="hs-comment">-- assert $ Less (Fst (ToGeneric v0)) (Snd (ToGeneric v0))</span><span>
</span><span id="line-141"></span><span class="hs-comment">-- Can't build a single-hole context for variable v0 in term Less (Fst (ToGeneric v0)) (Snd (ToGeneric v0))</span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="hs-comment">-- This gives us the _fundamental restriction_:</span><span>
</span><span id="line-144"></span><span class="hs-comment">--   A variable can not appear twice in the same constraint</span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span class="hs-comment">-- The fundamental restriction is very important to make the system compositional</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- and modular. We will get back to talking about it in detail when we discuss how to</span><span>
</span><span id="line-148"></span><span class="hs-comment">-- extend the system. However, for now suffice to say that it's a lot easier to solve</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- constraints that look like `2 * x &lt;. 10` than it is to solve constraints</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- like `x &lt;. 10 - x` (i.e. ones that mention the same variable more than once).</span><span>
</span><span id="line-151"></span><span>
</span><span id="line-152"></span><span class="hs-comment">-- To overcome the fundamental restriction we can use `match`:</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- match ::</span><span>
</span><span id="line-154"></span><span class="hs-comment">--   forall fn p a.</span><span>
</span><span id="line-155"></span><span class="hs-comment">--   ( HasSpec fn a</span><span>
</span><span id="line-156"></span><span class="hs-comment">--   , IsProductType fn a</span><span>
</span><span id="line-157"></span><span class="hs-comment">--   , IsPred p fn</span><span>
</span><span id="line-158"></span><span class="hs-comment">--   ) =&gt;</span><span>
</span><span id="line-159"></span><span class="hs-comment">--   Term fn a -&gt;</span><span>
</span><span id="line-160"></span><span class="hs-comment">--   FunTy (MapList (Term fn) (ProductAsList a)) p -&gt;</span><span>
</span><span id="line-161"></span><span class="hs-comment">--   Pred fn</span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specProd1"><span class="hs-identifier hs-type">specProd1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span id="specProd1"><span class="annot"><span class="annottext">specProd1 :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#specProd1"><span class="hs-identifier hs-var hs-var">specProd1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872846"><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872846"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-165"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Int, Int)
</span><a href="#local-6989586621679872846"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872844"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872844"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872843"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872843"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-166"></span><span>    </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872844"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872843"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-167"></span><span>
</span><span id="line-168"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec specProd1</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- (-1,0)</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- (-4,-2)</span><span>
</span><span id="line-171"></span><span class="hs-comment">-- (1,2)</span><span>
</span><span id="line-172"></span><span class="hs-comment">-- (-2,1)</span><span>
</span><span id="line-173"></span><span class="hs-comment">-- (7,8)</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- (-9,-4)</span><span>
</span><span id="line-175"></span><span class="hs-comment">-- (-3,3)</span><span>
</span><span id="line-176"></span><span class="hs-comment">-- (-1,12)</span><span>
</span><span id="line-177"></span><span class="hs-comment">-- (-7,-6)</span><span>
</span><span id="line-178"></span><span class="hs-comment">-- (-11,17)</span><span>
</span><span id="line-179"></span><span class="hs-comment">-- (-53,-14)</span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- Bringing variables into scope.</span><span>
</span><span id="line-182"></span><span class="hs-comment">-- 'constrained' and 'match' are the ways we bring variable into scope, And they are often nested.</span><span>
</span><span id="line-183"></span><span class="hs-comment">-- Consider writing a specification for pair of nested pairs: Specification fn ((Int,Int),(Int,Int))</span><span>
</span><span id="line-184"></span><span class="hs-comment">-- How do we name the four different Int's ?</span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#nested"><span class="hs-identifier hs-type">nested</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-187"></span><span id="nested"><span class="annot"><span class="annottext">nested :: Specification BaseFn ((Int, Int), (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#nested"><span class="hs-identifier hs-var hs-var">nested</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-188"></span><span>  </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872841"><span class="annot"><span class="annottext">Term BaseFn ((Int, Int), (Int, Int))
</span><a href="#local-6989586621679872841"><span class="hs-identifier hs-var">pp</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-189"></span><span>    </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn ((Int, Int), (Int, Int))
</span><a href="#local-6989586621679872841"><span class="hs-identifier hs-var">pp</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872840"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872840"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621679872839"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872839"><span class="hs-identifier hs-var">p2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-190"></span><span>      </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872840"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872838"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872838"><span class="hs-identifier hs-var">x1</span></a></span></span><span> </span><span id="local-6989586621679872837"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872837"><span class="hs-identifier hs-var">y1</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-191"></span><span>        </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872839"><span class="hs-identifier hs-var">p2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872836"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872836"><span class="hs-identifier hs-var">x2</span></a></span></span><span> </span><span id="local-6989586621679872835"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872835"><span class="hs-identifier hs-var">y2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-192"></span><span>          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872838"><span class="hs-identifier hs-var">x1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872837"><span class="hs-identifier hs-var">y1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872837"><span class="hs-identifier hs-var">y1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872836"><span class="hs-identifier hs-var">x2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872836"><span class="hs-identifier hs-var">x2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872835"><span class="hs-identifier hs-var">y2</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-193"></span><span>
</span><span id="line-194"></span><span class="hs-comment">-- ghci&gt; sample $ genFromSpec nested</span><span>
</span><span id="line-195"></span><span class="hs-comment">-- ((0,0),(0,0))</span><span>
</span><span id="line-196"></span><span class="hs-comment">-- ((-9,-5),(-1,0))</span><span>
</span><span id="line-197"></span><span class="hs-comment">-- ((-12,-10),(-5,-2))</span><span>
</span><span id="line-198"></span><span class="hs-comment">-- ((-8,-4),(-3,-2))</span><span>
</span><span id="line-199"></span><span class="hs-comment">-- ((-33,-18),(-15,-6))</span><span>
</span><span id="line-200"></span><span class="hs-comment">-- ((-21,-12),(-1,3))</span><span>
</span><span id="line-201"></span><span class="hs-comment">-- ((-36,-12),(1,9))</span><span>
</span><span id="line-202"></span><span class="hs-comment">-- ((-64,-37),(-30,-4))</span><span>
</span><span id="line-203"></span><span class="hs-comment">-- ((-53,-37),(-33,-10))</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- ((-49,-15),(-6,8))</span><span>
</span><span id="line-205"></span><span class="hs-comment">-- ((-72,-34),(-26,-19))</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span class="hs-comment">-- A good rule of thumb when starting a new specification is to think about how you would</span><span>
</span><span id="line-208"></span><span class="hs-comment">-- use 'constrained' and 'match' to bring variables, naming each of the parts that you want</span><span>
</span><span id="line-209"></span><span class="hs-comment">-- to constrain, into scope.</span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span class="hs-comment">-- Let's look under the hood of `match`, it introduces two auxilliary variables `v0` and `v1`</span><span>
</span><span id="line-212"></span><span class="hs-comment">-- that circumvents the fundamental restriction by allowing us to generate values for `v1` and</span><span>
</span><span id="line-213"></span><span class="hs-comment">-- `v0` before we generate a value for `v3`.</span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span class="hs-comment">-- &#955;&gt; simplifySpec specProd1</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- constrained $ \ v3 -&gt;</span><span>
</span><span id="line-217"></span><span class="hs-comment">--   let v1 = Fst (ToGeneric v3) in</span><span>
</span><span id="line-218"></span><span class="hs-comment">--   let v0 = Snd (ToGeneric v3) in</span><span>
</span><span id="line-219"></span><span class="hs-comment">--   assert $ Less v1 v0</span><span>
</span><span id="line-220"></span><span>
</span><span id="line-221"></span><span class="hs-comment">-- This pattern of `constrained $ \ p -&gt; match p $ \ x y -&gt; ...` is very common</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- and has a shorthand in the form of `constrained'`:</span><span>
</span><span id="line-223"></span><span>
</span><span id="line-224"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#specProd2"><span class="hs-identifier hs-type">specProd2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-225"></span><span id="specProd2"><span class="annot"><span class="annottext">specProd2 :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#specProd2"><span class="hs-identifier hs-var hs-var">specProd2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872831"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872831"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872830"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872830"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872831"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872830"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="hs-comment">-- How does generation actually work when we have multiple variables? For example,</span><span>
</span><span id="line-228"></span><span class="hs-comment">-- it is not obvious (to the computer) what the best way of generating values satisfying</span><span>
</span><span id="line-229"></span><span class="hs-comment">-- this constraint is:</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#solverOrder"><span class="hs-identifier hs-type">solverOrder</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span id="solverOrder"><span class="annot"><span class="annottext">solverOrder :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#solverOrder"><span class="hs-identifier hs-var hs-var">solverOrder</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872828"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872828"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872827"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872827"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-233"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872828"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872827"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872827"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-235"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span class="hs-comment">-- For example, if you tried generating a value for `x` first chances are you'd generate</span><span>
</span><span id="line-238"></span><span class="hs-comment">-- something larger than 10, which would make it impossible to generate a valid `y`. However,</span><span>
</span><span id="line-239"></span><span class="hs-comment">-- when we run it we get reasonable values out:</span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span class="hs-comment">-- sample $ genFromSpec solverOrder</span><span>
</span><span id="line-242"></span><span class="hs-comment">-- (-1,0)</span><span>
</span><span id="line-243"></span><span class="hs-comment">-- (0,2)</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- (-4,4)</span><span>
</span><span id="line-245"></span><span class="hs-comment">-- (-7,-3)</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- (-7,3)</span><span>
</span><span id="line-247"></span><span class="hs-comment">-- (-11,-3)</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- (4,8)</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- (-15,-14)</span><span>
</span><span id="line-250"></span><span class="hs-comment">-- (-25,-10)</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- (-23,-6)</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- (-51,-20)</span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="hs-comment">-- But how does the system know to generate `y` first? Unfortunately, there is nothing smart about</span><span>
</span><span id="line-255"></span><span class="hs-comment">-- it. The system simply solves things &quot;right to left&quot; - variables that appear to the right in assertions</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- are solved before variables to the left. If one wants to understand the consequences of this and how it</span><span>
</span><span id="line-257"></span><span class="hs-comment">-- affects the generator the `printPlan` function comes in handy:</span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span class="hs-comment">-- &#955;&gt; printPlan solverOrder</span><span>
</span><span id="line-260"></span><span class="hs-comment">-- Simplified spec:</span><span>
</span><span id="line-261"></span><span class="hs-comment">--   constrained $ \ v_3 -&gt;</span><span>
</span><span id="line-262"></span><span class="hs-comment">--     let v_1 = Fst (ToGeneric v_3) in</span><span>
</span><span id="line-263"></span><span class="hs-comment">--     let v_0 = Snd (ToGeneric v_3) in</span><span>
</span><span id="line-264"></span><span class="hs-comment">--     {assert $ Less v_0 10</span><span>
</span><span id="line-265"></span><span class="hs-comment">--      assert $ Less v_1 v_0}</span><span>
</span><span id="line-266"></span><span class="hs-comment">-- SolverPlan</span><span>
</span><span id="line-267"></span><span class="hs-comment">--   Dependencies:</span><span>
</span><span id="line-268"></span><span class="hs-comment">--     v_0 &lt;- []</span><span>
</span><span id="line-269"></span><span class="hs-comment">--     v_1 &lt;- [v_0]</span><span>
</span><span id="line-270"></span><span class="hs-comment">--     v_3 &lt;- [v_0, v_1]</span><span>
</span><span id="line-271"></span><span class="hs-comment">--   Linearization:</span><span>
</span><span id="line-272"></span><span class="hs-comment">--     v_0 &lt;- TypeSpec [..9] []</span><span>
</span><span id="line-273"></span><span class="hs-comment">--     v_1 &lt;- assert $ Less v_1 v_0</span><span>
</span><span id="line-274"></span><span class="hs-comment">--     v_3 &lt;-</span><span>
</span><span id="line-275"></span><span class="hs-comment">--       assert $ Equal (Fst (ToGeneric v_3)) v_1</span><span>
</span><span id="line-276"></span><span class="hs-comment">--       assert $ Equal (Snd (ToGeneric v_3)) v_0</span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="hs-comment">-- There are three parts to the output:</span><span>
</span><span id="line-279"></span><span class="hs-comment">--  - The &quot;Simplified spec&quot; is the input specification after it has gone through a number of optimization</span><span>
</span><span id="line-280"></span><span class="hs-comment">--    and simplification passes to make it amenable to solving.</span><span>
</span><span id="line-281"></span><span class="hs-comment">--  - The &quot;Dependencies&quot; tells us what variables depend on what other variables to be solved. In this case `v0` (y)</span><span>
</span><span id="line-282"></span><span class="hs-comment">--    has no dependencies, `v1` (x) is solved after `v0` and `v3` (the actual pair we are generating) is solved</span><span>
</span><span id="line-283"></span><span class="hs-comment">--    last.</span><span>
</span><span id="line-284"></span><span class="hs-comment">--  - Finaly, the &quot;Linearization&quot; tells us _what constraints define what varible_. This is an important aspect of the</span><span>
</span><span id="line-285"></span><span class="hs-comment">--    system: variables are only constrained by assertions that talk about the variable itself and variables that</span><span>
</span><span id="line-286"></span><span class="hs-comment">--    are solved before it. In this case `v0` (y) is defined by `y &lt;. 10`, `v1` (x) by `x &lt;. y` and `v3` by the equalities</span><span>
</span><span id="line-287"></span><span class="hs-comment">--    in the `Let` constructs.</span><span>
</span><span id="line-288"></span><span class="hs-comment">--</span><span>
</span><span id="line-289"></span><span class="hs-comment">-- As the generator executes this plan it will pick the variables in the order in which they appear in the linearization</span><span>
</span><span id="line-290"></span><span class="hs-comment">-- and generate the corresponding values. For example, an execution trace could go like the following pseudo-trace (the details of how</span><span>
</span><span id="line-291"></span><span class="hs-comment">-- this works are slightly more involved but the basic order of operations is accurate):</span><span>
</span><span id="line-292"></span><span class="hs-comment">--  v0 &lt;- pick from (-&#8734;, 10)</span><span>
</span><span id="line-293"></span><span class="hs-comment">--  v0 = 4</span><span>
</span><span id="line-294"></span><span class="hs-comment">--  v1 &lt;- pick from [4/v0](-&#8734;, v0)</span><span>
</span><span id="line-295"></span><span class="hs-comment">--        -&gt; pick from (-&#8734;, 4)</span><span>
</span><span id="line-296"></span><span class="hs-comment">--  v1 = 2</span><span>
</span><span id="line-297"></span><span class="hs-comment">--  v3 &lt;- pick from [4/v0, 2/v1]{fst == v1, snd == v0}</span><span>
</span><span id="line-298"></span><span class="hs-comment">--        -&gt; pick from {fst == 2, snd == 4}</span><span>
</span><span id="line-299"></span><span class="hs-comment">--  v3 = (2, 4)</span><span>
</span><span id="line-300"></span><span>
</span><span id="line-301"></span><span class="hs-comment">-- As an aside, the frustrating thing about making sense of the output of `printPlan` is the `v0`, `v1`, etc. naming.</span><span>
</span><span id="line-302"></span><span class="hs-comment">-- To introduce proper names we can use the `var` quasi-quoter:</span><span>
</span><span id="line-303"></span><span>
</span><span id="line-304"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#solverOrder%27"><span class="hs-identifier hs-type">solverOrder'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-305"></span><span id="solverOrder%27"><span class="annot"><span class="annottext">solverOrder' :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#solverOrder%27"><span class="hs-identifier hs-var hs-var">solverOrder'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="">[var|x|]</span></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="">[var|y|]</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-306"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872824"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872823"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872823"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-308"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span class="hs-comment">-- Now we get more reasonable looking oputput from `printPlan`:</span><span>
</span><span id="line-311"></span><span class="hs-comment">-- &#955;&gt; printPlan solverOrder'</span><span>
</span><span id="line-312"></span><span class="hs-comment">-- Simplified spec:</span><span>
</span><span id="line-313"></span><span class="hs-comment">--   constrained $ \ v_3 -&gt;</span><span>
</span><span id="line-314"></span><span class="hs-comment">--     let x_1 = Fst (ToGeneric v_3) in</span><span>
</span><span id="line-315"></span><span class="hs-comment">--     let y_0 = Snd (ToGeneric v_3) in</span><span>
</span><span id="line-316"></span><span class="hs-comment">--     {assert $ Less y_0 10</span><span>
</span><span id="line-317"></span><span class="hs-comment">--      assert $ Less x_1 y_0}</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- SolverPlan</span><span>
</span><span id="line-319"></span><span class="hs-comment">--   Dependencies:</span><span>
</span><span id="line-320"></span><span class="hs-comment">--     y_0 &lt;- []</span><span>
</span><span id="line-321"></span><span class="hs-comment">--     x_1 &lt;- [y_0]</span><span>
</span><span id="line-322"></span><span class="hs-comment">--     v_3 &lt;- [y_0, x_1]</span><span>
</span><span id="line-323"></span><span class="hs-comment">--   Linearization:</span><span>
</span><span id="line-324"></span><span class="hs-comment">--     y_0 &lt;- TypeSpec [..9] []</span><span>
</span><span id="line-325"></span><span class="hs-comment">--     x_1 &lt;- assert $ Less x_1 y_0</span><span>
</span><span id="line-326"></span><span class="hs-comment">--     v_3 &lt;-</span><span>
</span><span id="line-327"></span><span class="hs-comment">--       assert $ Equal (Fst (ToGeneric v_3)) x_1</span><span>
</span><span id="line-328"></span><span class="hs-comment">--       assert $ Equal (Snd (ToGeneric v_3)) y_0</span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span class="hs-comment">-- A consequence of the default dependency order approach is that it's possible</span><span>
</span><span id="line-331"></span><span class="hs-comment">-- to write constraints that put you in a tricky situation:</span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#tightFit0"><span class="hs-identifier hs-type">tightFit0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-334"></span><span id="tightFit0"><span class="annot"><span class="annottext">tightFit0 :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#tightFit0"><span class="hs-identifier hs-var hs-var">tightFit0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872821"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872821"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872820"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872820"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-335"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872821"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-336"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872821"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872820"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-337"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-338"></span><span>
</span><span id="line-339"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec tightFit0</span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="hs-comment">-- *** Exception: genFromPreds:</span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">--   let v_1 = Fst (ToGeneric v_3) in</span><span>
</span><span id="line-344"></span><span class="hs-comment">--   let v_0 = Snd (ToGeneric v_3) in</span><span>
</span><span id="line-345"></span><span class="hs-comment">--   {assert $ Less v_1 v_0</span><span>
</span><span id="line-346"></span><span class="hs-comment">--    assert $ Less 0 v_1}</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- SolverPlan</span><span>
</span><span id="line-348"></span><span class="hs-comment">--   Dependencies:</span><span>
</span><span id="line-349"></span><span class="hs-comment">--     v_0 &lt;- []</span><span>
</span><span id="line-350"></span><span class="hs-comment">--     v_1 &lt;- [v_0]</span><span>
</span><span id="line-351"></span><span class="hs-comment">--     v_3 &lt;- [v_0, v_1]</span><span>
</span><span id="line-352"></span><span class="hs-comment">--   Linearization:</span><span>
</span><span id="line-353"></span><span class="hs-comment">--     v_0 &lt;-</span><span>
</span><span id="line-354"></span><span class="hs-comment">--     v_1 &lt;-</span><span>
</span><span id="line-355"></span><span class="hs-comment">--       TypeSpec [1..] []</span><span>
</span><span id="line-356"></span><span class="hs-comment">--       ---</span><span>
</span><span id="line-357"></span><span class="hs-comment">--       assert $ Less v_1 v_0</span><span>
</span><span id="line-358"></span><span class="hs-comment">--     v_3 &lt;-</span><span>
</span><span id="line-359"></span><span class="hs-comment">--       assert $ Equal (Fst (ToGeneric v_3)) v_1</span><span>
</span><span id="line-360"></span><span class="hs-comment">--       assert $ Equal (Snd (ToGeneric v_3)) v_0</span><span>
</span><span id="line-361"></span><span class="hs-comment">-- Stepping the plan:</span><span>
</span><span id="line-362"></span><span class="hs-comment">--   SolverPlan</span><span>
</span><span id="line-363"></span><span class="hs-comment">--     Dependencies:</span><span>
</span><span id="line-364"></span><span class="hs-comment">--       v_1 &lt;- []</span><span>
</span><span id="line-365"></span><span class="hs-comment">--       v_3 &lt;- [v_1]</span><span>
</span><span id="line-366"></span><span class="hs-comment">--     Linearization:</span><span>
</span><span id="line-367"></span><span class="hs-comment">--       v_1 &lt;- ErrorSpec [1..-1]</span><span>
</span><span id="line-368"></span><span class="hs-comment">--       v_3 &lt;-</span><span>
</span><span id="line-369"></span><span class="hs-comment">--         TypeSpec (Cartesian TrueSpec (MemberSpec [0])) []</span><span>
</span><span id="line-370"></span><span class="hs-comment">--         ---</span><span>
</span><span id="line-371"></span><span class="hs-comment">--         assert $ Equal (Fst (ToGeneric v_3)) v_1</span><span>
</span><span id="line-372"></span><span class="hs-comment">--   Env {unEnv = fromList [(v_0,EnvValue 0)]}</span><span>
</span><span id="line-373"></span><span class="hs-comment">-- genFromSpecT ErrorSpec{} with explanation:</span><span>
</span><span id="line-374"></span><span class="hs-comment">-- [1..-1]</span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span class="hs-comment">-- The generator fails with output similar to what we saw above and a message telling us we tried to generate</span><span>
</span><span id="line-377"></span><span class="hs-comment">-- a value from the (empty) interval [1..-1]. Inspecting the output above carefully we see that the graph and the</span><span>
</span><span id="line-378"></span><span class="hs-comment">-- linearization tell us that `v0` (y) is completely unconstrained. The consequence of this is that when we get to the</span><span>
</span><span id="line-379"></span><span class="hs-comment">-- point of trying to generate `v1` (x) we've already picked a value (-1) for `v0` that makes it impossible to satisfy</span><span>
</span><span id="line-380"></span><span class="hs-comment">-- the constraints on `v1` and its constraints have specialized away to an error spec.</span><span>
</span><span id="line-381"></span><span>
</span><span id="line-382"></span><span class="hs-comment">-- The solution to this issue is to introduce `dependsOn`, which lets us override the dependency order in constraints:</span><span>
</span><span id="line-383"></span><span>
</span><span id="line-384"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#tightFit1"><span class="hs-identifier hs-type">tightFit1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-385"></span><span id="tightFit1"><span class="annot"><span class="annottext">tightFit1 :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#tightFit1"><span class="hs-identifier hs-var hs-var">tightFit1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872818"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872818"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872817"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872817"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872818"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-387"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872818"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872817"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872817"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Pred fn
</span><a href="Constrained.Base.html#dependsOn"><span class="hs-operator hs-var">`dependsOn`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872818"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-390"></span><span>
</span><span id="line-391"></span><span class="hs-comment">-- &#955;&gt; printPlan tightFit1</span><span>
</span><span id="line-392"></span><span class="hs-comment">-- Simplified spec:</span><span>
</span><span id="line-393"></span><span class="hs-comment">--   constrained $ \ v_3 -&gt;</span><span>
</span><span id="line-394"></span><span class="hs-comment">--     let v_1 = Fst (ToGeneric v_3) in</span><span>
</span><span id="line-395"></span><span class="hs-comment">--     let v_0 = Snd (ToGeneric v_3) in</span><span>
</span><span id="line-396"></span><span class="hs-comment">--     {v_0 &lt;- v_1</span><span>
</span><span id="line-397"></span><span class="hs-comment">--      assert $ Less v_1 v_0</span><span>
</span><span id="line-398"></span><span class="hs-comment">--      assert $ Less 0 v_1}</span><span>
</span><span id="line-399"></span><span class="hs-comment">-- SolverPlan</span><span>
</span><span id="line-400"></span><span class="hs-comment">--   Dependencies:</span><span>
</span><span id="line-401"></span><span class="hs-comment">--     v_0 &lt;- [v_1]</span><span>
</span><span id="line-402"></span><span class="hs-comment">--     v_1 &lt;- []</span><span>
</span><span id="line-403"></span><span class="hs-comment">--     v_3 &lt;- [v_0, v_1]</span><span>
</span><span id="line-404"></span><span class="hs-comment">--   Linearization:</span><span>
</span><span id="line-405"></span><span class="hs-comment">--     v_1 &lt;- TypeSpec [1..] []</span><span>
</span><span id="line-406"></span><span class="hs-comment">--     v_0 &lt;- assert $ Less v_1 v_0</span><span>
</span><span id="line-407"></span><span class="hs-comment">--     v_3 &lt;-</span><span>
</span><span id="line-408"></span><span class="hs-comment">--       assert $ Equal (Fst (ToGeneric v_3)) v_1</span><span>
</span><span id="line-409"></span><span class="hs-comment">--       assert $ Equal (Snd (ToGeneric v_3)) v_0</span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span class="hs-comment">-- This gives us more balanced constraints that solve `v1` before they solve `v0`!</span><span>
</span><span id="line-412"></span><span class="hs-comment">-- Consequently, this constraint generates reasonable values:</span><span>
</span><span id="line-413"></span><span>
</span><span id="line-414"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec tightFit1</span><span>
</span><span id="line-415"></span><span class="hs-comment">-- (1,2)</span><span>
</span><span id="line-416"></span><span class="hs-comment">-- (2,3)</span><span>
</span><span id="line-417"></span><span class="hs-comment">-- (9,15)</span><span>
</span><span id="line-418"></span><span class="hs-comment">-- (4,10)</span><span>
</span><span id="line-419"></span><span class="hs-comment">-- (12,27)</span><span>
</span><span id="line-420"></span><span class="hs-comment">-- (15,21)</span><span>
</span><span id="line-421"></span><span class="hs-comment">-- (10,30)</span><span>
</span><span id="line-422"></span><span class="hs-comment">-- (23,51)</span><span>
</span><span id="line-423"></span><span class="hs-comment">-- (7,34)</span><span>
</span><span id="line-424"></span><span class="hs-comment">-- (21,46)</span><span>
</span><span id="line-425"></span><span class="hs-comment">-- (28,49)</span><span>
</span><span id="line-426"></span><span>
</span><span id="line-427"></span><span class="hs-comment">-- We also support booleans with `ifElse :: Term fn Bool -&gt; Pred fn -&gt; Pred fn -&gt; Pred fn`</span><span>
</span><span id="line-428"></span><span class="hs-comment">-- where the branches of the `ifElse` depend on the scrutinee.</span><span>
</span><span id="line-429"></span><span>
</span><span id="line-430"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#booleanExample"><span class="hs-identifier hs-type">booleanExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-431"></span><span id="booleanExample"><span class="annot"><span class="annottext">booleanExample :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#booleanExample"><span class="hs-identifier hs-var hs-var">booleanExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872814"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872814"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679872813"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872813"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-432"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) p q.
(BaseUniverse fn, IsPred p fn, IsPred q fn) =&gt;
Term fn Bool -&gt; p -&gt; q -&gt; Pred fn
</span><a href="Constrained.Base.html#ifElse"><span class="hs-identifier hs-var">ifElse</span></a></span><span>
</span><span id="line-433"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872814"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-434"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872813"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span class="hs-special">)</span><span>
</span><span id="line-435"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872813"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">20</span></span><span class="hs-special">)</span><span>
</span><span id="line-436"></span><span>
</span><span id="line-437"></span><span class="hs-comment">-- sample $ genFromSpec booleanExample</span><span>
</span><span id="line-438"></span><span class="hs-comment">-- (0,20)</span><span>
</span><span id="line-439"></span><span class="hs-comment">-- (2,10)</span><span>
</span><span id="line-440"></span><span class="hs-comment">-- (4,10)</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- (1,10)</span><span>
</span><span id="line-442"></span><span class="hs-comment">-- (-2,20)</span><span>
</span><span id="line-443"></span><span class="hs-comment">-- (3,10)</span><span>
</span><span id="line-444"></span><span class="hs-comment">-- (7,10)</span><span>
</span><span id="line-445"></span><span class="hs-comment">-- (-8,20)</span><span>
</span><span id="line-446"></span><span class="hs-comment">-- (-5,20)</span><span>
</span><span id="line-447"></span><span class="hs-comment">-- (-2,20)</span><span>
</span><span id="line-448"></span><span class="hs-comment">-- (-19,20)</span><span>
</span><span id="line-449"></span><span>
</span><span id="line-450"></span><span class="hs-comment">-- We can combine `ifElse` and `dependsOn` to write a nice example saying</span><span>
</span><span id="line-451"></span><span class="hs-comment">-- that a PVP version pair `q` can follow a pair `p`.</span><span>
</span><span id="line-452"></span><span>
</span><span id="line-453"></span><span class="hs-comment">-- Because we will need to re-use this multiple times we start by defining a valid</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- PVP constraint as any constraint that has non-negative major and minor version number.</span><span>
</span><span id="line-455"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#validPVPVersion"><span class="hs-identifier hs-type">validPVPVersion</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span id="validPVPVersion"><span class="annot"><span class="annottext">validPVPVersion :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#validPVPVersion"><span class="hs-identifier hs-var hs-var">validPVPVersion</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872809"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872809"><span class="hs-identifier hs-var">ma</span></a></span></span><span> </span><span id="local-6989586621679872808"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872808"><span class="hs-identifier hs-var">mi</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872809"><span class="hs-identifier hs-var">ma</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872808"><span class="hs-identifier hs-var">mi</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-457"></span><span>
</span><span id="line-458"></span><span class="hs-comment">-- Now we are ready to define the constraints for valid PVP succession. Note here that</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- we use the `satisfies :: Term fn a -&gt; Specification BaseFn a -&gt; Pred fn` combinator</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- to re-use the `validPVPVersion` constraint.</span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#canFollowExample"><span class="hs-identifier hs-type">canFollowExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-463"></span><span id="canFollowExample"><span class="annot"><span class="annottext">canFollowExample :: Specification BaseFn ((Int, Int), (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#canFollowExample"><span class="hs-identifier hs-var hs-var">canFollowExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872806"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872806"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679872805"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872805"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-464"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872806"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872804"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872804"><span class="hs-identifier hs-var">ma</span></a></span></span><span> </span><span id="local-6989586621679872803"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872803"><span class="hs-identifier hs-var">mi</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-465"></span><span>      </span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, IsProductType fn a, IsPred p fn) =&gt;
Term fn a
-&gt; FunTy (MapList (Term fn) (ProductAsList a)) p -&gt; Pred fn
</span><a href="Constrained.Spec.Generics.html#match"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872805"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872802"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872802"><span class="hs-identifier hs-var">ma'</span></a></span></span><span> </span><span id="local-6989586621679872801"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872801"><span class="hs-identifier hs-var">mi'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-466"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p q.
(BaseUniverse fn, IsPred p fn, IsPred q fn) =&gt;
Term fn Bool -&gt; p -&gt; q -&gt; Pred fn
</span><a href="Constrained.Base.html#ifElse"><span class="hs-identifier hs-var">ifElse</span></a></span><span>
</span><span id="line-467"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872802"><span class="hs-identifier hs-var">ma'</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872804"><span class="hs-identifier hs-var">ma</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-468"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872801"><span class="hs-identifier hs-var">mi'</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872803"><span class="hs-identifier hs-var">mi</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-469"></span><span>            </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872801"><span class="hs-identifier hs-var">mi'</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-470"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- Note how these two constraints imply a cycle:</span><span>
</span><span id="line-471"></span><span>          </span><span class="hs-comment">--  ma' &lt;- ma &lt;- ma'</span><span>
</span><span id="line-472"></span><span>          </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872802"><span class="hs-identifier hs-var">ma'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872804"><span class="hs-identifier hs-var">ma</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">+</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-473"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872804"><span class="hs-identifier hs-var">ma</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872802"><span class="hs-identifier hs-var">ma'</span></a></span><span>
</span><span id="line-474"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- We break that cycle by specifying a concrete order</span><span>
</span><span id="line-475"></span><span>          </span><span class="hs-comment">-- Another option would be to define `&gt;=.` but that doesn't</span><span>
</span><span id="line-476"></span><span>          </span><span class="hs-comment">-- exist right now and we will get to extending the language</span><span>
</span><span id="line-477"></span><span>          </span><span class="hs-comment">-- later on!</span><span>
</span><span id="line-478"></span><span>          </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872802"><span class="hs-identifier hs-var">ma'</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Pred fn
</span><a href="Constrained.Base.html#dependsOn"><span class="hs-operator hs-var">`dependsOn`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872804"><span class="hs-identifier hs-var">ma</span></a></span><span>
</span><span id="line-479"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-480"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872806"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Specification fn a -&gt; Pred fn
</span><a href="Constrained.Base.html#satisfies"><span class="hs-operator hs-var">`satisfies`</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#validPVPVersion"><span class="hs-identifier hs-var">validPVPVersion</span></a></span><span>
</span><span id="line-481"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872805"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Specification fn a -&gt; Pred fn
</span><a href="Constrained.Base.html#satisfies"><span class="hs-operator hs-var">`satisfies`</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#validPVPVersion"><span class="hs-identifier hs-var">validPVPVersion</span></a></span><span>
</span><span id="line-482"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-483"></span><span>
</span><span id="line-484"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec canFollowExample</span><span>
</span><span id="line-485"></span><span class="hs-comment">-- ((0,0),(0,1))</span><span>
</span><span id="line-486"></span><span class="hs-comment">-- ((1,0),(1,1))</span><span>
</span><span id="line-487"></span><span class="hs-comment">-- ((4,2),(4,3))</span><span>
</span><span id="line-488"></span><span class="hs-comment">-- ((12,1),(12,2))</span><span>
</span><span id="line-489"></span><span class="hs-comment">-- ((11,16),(11,17))</span><span>
</span><span id="line-490"></span><span class="hs-comment">-- ((20,7),(21,0))</span><span>
</span><span id="line-491"></span><span class="hs-comment">-- ((18,12),(18,13))</span><span>
</span><span id="line-492"></span><span class="hs-comment">-- ((6,18),(7,0))</span><span>
</span><span id="line-493"></span><span class="hs-comment">-- ((29,24),(30,0))</span><span>
</span><span id="line-494"></span><span class="hs-comment">-- ((23,21),(23,22))</span><span>
</span><span id="line-495"></span><span class="hs-comment">-- ((26,14),(26,15))</span><span>
</span><span id="line-496"></span><span>
</span><span id="line-497"></span><span class="hs-comment">-- We have native support for sum types using `caseOn` and `branch`:</span><span>
</span><span id="line-498"></span><span>
</span><span id="line-499"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#sumExample"><span class="hs-identifier hs-type">sumExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-500"></span><span id="sumExample"><span class="annot"><span class="annottext">sumExample :: Specification BaseFn (Either Int Bool)
</span><a href="Constrained.Examples.CheatSheet.html#sumExample"><span class="hs-identifier hs-var hs-var">sumExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872797"><span class="annot"><span class="annottext">Term BaseFn (Either Int Bool)
</span><a href="#local-6989586621679872797"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-501"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, HasSpec fn (SimpleRep a), HasSimpleRep a,
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 SimpleRep a ~ SumOver (Cases (SimpleRep a)),
 TypeList (Cases (SimpleRep a))) =&gt;
Term fn a
-&gt; FunTy
     (MapList (Weighted (Binder fn)) (Cases (SimpleRep a))) (Pred fn)
</span><a href="Constrained.Spec.Generics.html#caseOn"><span class="hs-identifier hs-var">caseOn</span></a></span><span> </span><span class="annot"><span class="annottext">Term BaseFn (Either Int Bool)
</span><a href="#local-6989586621679872797"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-502"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872794"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872794"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872794"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-503"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872793"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872793"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
BaseUniverse fn =&gt;
Term fn Bool -&gt; Term fn Bool
</span><a href="Constrained.Base.html#not_"><span class="hs-identifier hs-var">not_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872793"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="hs-comment">-- Furthermore, cases are solved _inside-out_ by default:</span><span>
</span><span id="line-506"></span><span>
</span><span id="line-507"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#sumExampleTwo"><span class="hs-identifier hs-type">sumExampleTwo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-508"></span><span id="sumExampleTwo"><span class="annot"><span class="annottext">sumExampleTwo :: Specification BaseFn (Int, Either Int Bool)
</span><a href="Constrained.Examples.CheatSheet.html#sumExampleTwo"><span class="hs-identifier hs-var hs-var">sumExampleTwo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872790"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872790"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679872789"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Either Int Bool)
</span><a href="#local-6989586621679872789"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, HasSpec fn (SimpleRep a), HasSimpleRep a,
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 SimpleRep a ~ SumOver (Cases (SimpleRep a)),
 TypeList (Cases (SimpleRep a))) =&gt;
Term fn a
-&gt; FunTy
     (MapList (Weighted (Binder fn)) (Cases (SimpleRep a))) (Pred fn)
</span><a href="Constrained.Spec.Generics.html#caseOn"><span class="hs-identifier hs-var">caseOn</span></a></span><span>
</span><span id="line-510"></span><span>      </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Either Int Bool)
</span><a href="#local-6989586621679872789"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-511"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872788"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872788"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872790"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872788"><span class="hs-identifier hs-var">j</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-512"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872787"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872787"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
BaseUniverse fn =&gt;
Term fn Bool -&gt; Term fn Bool
</span><a href="Constrained.Base.html#not_"><span class="hs-identifier hs-var">not_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872787"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-513"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">20</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872790"><span class="hs-identifier hs-var">i</span></a></span><span>
</span><span id="line-514"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-515"></span><span>
</span><span id="line-516"></span><span class="hs-comment">-- We can work with sets with operations like `subset_`, `union_` (or `&lt;&gt;`), `disjoint_`, and `singleton_`:</span><span>
</span><span id="line-517"></span><span>
</span><span id="line-518"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#setExample"><span class="hs-identifier hs-type">setExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-519"></span><span id="setExample"><span class="annot"><span class="annottext">setExample :: Specification BaseFn (Set Int, Set Int, Set Int)
</span><a href="Constrained.Examples.CheatSheet.html#setExample"><span class="hs-identifier hs-var hs-var">setExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872785"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872785"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679872784"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872784"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span id="local-6989586621679872783"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872783"><span class="hs-identifier hs-var">zs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-520"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872785"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, Ord a) =&gt;
Term fn (Set a) -&gt; Term fn (Set a) -&gt; Term fn Bool
</span><a href="Constrained.Base.html#subset_"><span class="hs-operator hs-var">`subset_`</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872784"><span class="hs-identifier hs-var">ys</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872783"><span class="hs-identifier hs-var">zs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-521"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(HasSpec fn a, Sized a) =&gt;
Term fn a -&gt; Term fn Integer
</span><a href="Constrained.Base.html#sizeOf_"><span class="hs-identifier hs-var">sizeOf_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872784"><span class="hs-identifier hs-var">ys</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C%3D."><span class="hs-operator hs-var">&lt;=.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Integer
</span><span class="hs-number">10</span></span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span class="hs-comment">-- We can also quantify over things like sets with `forAll`:</span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#forAllFollow0"><span class="hs-identifier hs-type">forAllFollow0</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-527"></span><span id="forAllFollow0"><span class="annot"><span class="annottext">forAllFollow0 :: Specification BaseFn ((Int, Int), Set (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#forAllFollow0"><span class="hs-identifier hs-var hs-var">forAllFollow0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872779"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872779"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679872778"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set (Int, Int))
</span><a href="#local-6989586621679872778"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-528"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall t a (fn :: Univ) p.
(Forallable t a, HasSpec fn t, HasSpec fn a, IsPred p fn) =&gt;
Term fn t -&gt; (Term fn a -&gt; p) -&gt; Pred fn
</span><a href="Constrained.Base.html#forAll"><span class="hs-identifier hs-var">forAll</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set (Int, Int))
</span><a href="#local-6989586621679872778"><span class="hs-identifier hs-var">qs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872776"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872776"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Term fn (a, b)
</span><a href="Constrained.Spec.Generics.html#pair_"><span class="hs-identifier hs-var">pair_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872779"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872776"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Specification fn a -&gt; Pred fn
</span><a href="Constrained.Base.html#satisfies"><span class="hs-operator hs-var">`satisfies`</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn ((Int, Int), (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#canFollowExample"><span class="hs-identifier hs-var">canFollowExample</span></a></span><span>
</span><span id="line-529"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-530"></span><span>
</span><span id="line-531"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec forAllFollow0</span><span>
</span><span id="line-532"></span><span class="hs-comment">-- ((0,0),fromList [])</span><span>
</span><span id="line-533"></span><span class="hs-comment">-- ((1,-1),fromList [])</span><span>
</span><span id="line-534"></span><span class="hs-comment">-- ((2,3),fromList [(2,4),(3,0)])</span><span>
</span><span id="line-535"></span><span class="hs-comment">-- ((4,2),fromList [(4,3),(5,0)])</span><span>
</span><span id="line-536"></span><span class="hs-comment">-- ((-2,6),fromList [])</span><span>
</span><span id="line-537"></span><span class="hs-comment">-- ((10,-9),fromList [])</span><span>
</span><span id="line-538"></span><span class="hs-comment">-- ((-1,-8),fromList [])</span><span>
</span><span id="line-539"></span><span class="hs-comment">-- ((-8,-1),fromList [])</span><span>
</span><span id="line-540"></span><span class="hs-comment">-- ((1,4),fromList [(1,5),(2,0)])</span><span>
</span><span id="line-541"></span><span class="hs-comment">-- ((-17,-5),fromList [])</span><span>
</span><span id="line-542"></span><span class="hs-comment">-- ((-2,12),fromList [])</span><span>
</span><span id="line-543"></span><span>
</span><span id="line-544"></span><span class="hs-comment">-- How come the sets are so small? Note that we sometimes still generate</span><span>
</span><span id="line-545"></span><span class="hs-comment">-- negative values for the components of `p`. But we said in the `canFollowExample`</span><span>
</span><span id="line-546"></span><span class="hs-comment">-- that `p` needs to be a valid PVP version. However, the constraints only say that</span><span>
</span><span id="line-547"></span><span class="hs-comment">-- it needs to be a valid PVP version _if `qs` is non-empty!_. This is easily fixed</span><span>
</span><span id="line-548"></span><span class="hs-comment">-- by specifying that `p` is _always_ a valid PVP version!</span><span>
</span><span id="line-549"></span><span>
</span><span id="line-550"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#forAllFollow"><span class="hs-identifier hs-type">forAllFollow</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-551"></span><span id="forAllFollow"><span class="annot"><span class="annottext">forAllFollow :: Specification BaseFn ((Int, Int), Set (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#forAllFollow"><span class="hs-identifier hs-var hs-var">forAllFollow</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872773"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872773"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679872772"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set (Int, Int))
</span><a href="#local-6989586621679872772"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-552"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall t a (fn :: Univ) p.
(Forallable t a, HasSpec fn t, HasSpec fn a, IsPred p fn) =&gt;
Term fn t -&gt; (Term fn a -&gt; p) -&gt; Pred fn
</span><a href="Constrained.Base.html#forAll"><span class="hs-identifier hs-var">forAll</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set (Int, Int))
</span><a href="#local-6989586621679872772"><span class="hs-identifier hs-var">qs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872771"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872771"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Term fn (a, b)
</span><a href="Constrained.Spec.Generics.html#pair_"><span class="hs-identifier hs-var">pair_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872773"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872771"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Specification fn a -&gt; Pred fn
</span><a href="Constrained.Base.html#satisfies"><span class="hs-operator hs-var">`satisfies`</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn ((Int, Int), (Int, Int))
</span><a href="Constrained.Examples.CheatSheet.html#canFollowExample"><span class="hs-identifier hs-var">canFollowExample</span></a></span><span>
</span><span id="line-553"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Int, Int)
</span><a href="#local-6989586621679872773"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Specification fn a -&gt; Pred fn
</span><a href="Constrained.Base.html#satisfies"><span class="hs-operator hs-var">`satisfies`</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#validPVPVersion"><span class="hs-identifier hs-var">validPVPVersion</span></a></span><span>
</span><span id="line-554"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec forAllFollow</span><span>
</span><span id="line-557"></span><span class="hs-comment">-- ((0,0),fromList [])</span><span>
</span><span id="line-558"></span><span class="hs-comment">-- ((0,1),fromList [])</span><span>
</span><span id="line-559"></span><span class="hs-comment">-- ((1,5),fromList [(1,6),(2,0)])</span><span>
</span><span id="line-560"></span><span class="hs-comment">-- ((8,10),fromList [(8,11)])</span><span>
</span><span id="line-561"></span><span class="hs-comment">-- ((12,15),fromList [(12,16)])</span><span>
</span><span id="line-562"></span><span class="hs-comment">-- ((6,16),fromList [])</span><span>
</span><span id="line-563"></span><span class="hs-comment">-- ((4,11),fromList [(4,12)])</span><span>
</span><span id="line-564"></span><span class="hs-comment">-- ((10,21),fromList [(10,22),(11,0)])</span><span>
</span><span id="line-565"></span><span class="hs-comment">-- ((28,2),fromList [(28,3),(29,0)])</span><span>
</span><span id="line-566"></span><span class="hs-comment">-- ((20,3),fromList [(20,4),(21,0)])</span><span>
</span><span id="line-567"></span><span class="hs-comment">-- ((16,29),fromList [(16,30),(17,0)])</span><span>
</span><span id="line-568"></span><span>
</span><span id="line-569"></span><span class="hs-comment">-- We also have existential quantification in the language. The first argument to</span><span>
</span><span id="line-570"></span><span class="hs-comment">-- `exists` tells you how to reconstruct the value from known values.</span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#existentials"><span class="hs-identifier hs-type">existentials</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-type">Set</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-573"></span><span id="existentials"><span class="annot"><span class="annottext">existentials :: Specification BaseFn (Set Int, Set Int)
</span><a href="Constrained.Examples.CheatSheet.html#existentials"><span class="hs-identifier hs-var hs-var">existentials</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872769"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872769"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679872768"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872768"><span class="hs-identifier hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-574"></span><span>  </span><span class="annot"><span class="annottext">forall a p (fn :: Univ).
(HasSpec fn a, IsPred p fn) =&gt;
((forall b. Term fn b -&gt; b) -&gt; GE a) -&gt; (Term fn a -&gt; p) -&gt; Pred fn
</span><a href="Constrained.Base.html#exists"><span class="hs-identifier hs-var">exists</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679872766"><span class="annot"><span class="annottext">forall b.
Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  b
-&gt; b
</span><a href="#local-6989586621679872766"><span class="hs-identifier hs-var">eval</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/containers-0.6.5.1/src"><span class="hs-identifier hs-var">Set.intersection</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall b.
Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  b
-&gt; b
</span><a href="#local-6989586621679872766"><span class="hs-identifier hs-var">eval</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872769"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall b.
Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  b
-&gt; b
</span><a href="#local-6989586621679872766"><span class="hs-identifier hs-var">eval</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872768"><span class="hs-identifier hs-var">ys</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872764"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-575"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
BaseUniverse fn =&gt;
Term fn Bool -&gt; Term fn Bool
</span><a href="Constrained.Base.html#not_"><span class="hs-identifier hs-var">not_</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, Sized a) =&gt;
Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#null_"><span class="hs-identifier hs-var">null_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span><span>
</span><span id="line-576"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, Ord a) =&gt;
Term fn (Set a) -&gt; Term fn (Set a) -&gt; Term fn Bool
</span><a href="Constrained.Base.html#subset_"><span class="hs-operator hs-var">`subset_`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872769"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-577"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, Ord a) =&gt;
Term fn (Set a) -&gt; Term fn (Set a) -&gt; Term fn Bool
</span><a href="Constrained.Base.html#subset_"><span class="hs-operator hs-var">`subset_`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872768"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-578"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872769"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Pred fn
</span><a href="Constrained.Base.html#dependsOn"><span class="hs-operator hs-var">`dependsOn`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span><span>
</span><span id="line-579"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872768"><span class="hs-identifier hs-var">ys</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Pred fn
</span><a href="Constrained.Base.html#dependsOn"><span class="hs-operator hs-var">`dependsOn`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  (Set Int)
</span><a href="#local-6989586621679872764"><span class="hs-identifier hs-var">zs</span></a></span><span>
</span><span id="line-580"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-581"></span><span>
</span><span id="line-582"></span><span class="hs-comment">-- You can work with your own types relatively easily. If they are `Generic`</span><span>
</span><span id="line-583"></span><span class="hs-comment">-- you even get all the machinery of sum and product types for free!</span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span id="local-6989586621679872761"><span id="local-6989586621679872762"></span></span><span class="hs-keyword">data</span><span> </span><span id="FooBarBaz"><span class="annot"><a href="Constrained.Examples.CheatSheet.html#FooBarBaz"><span class="hs-identifier hs-var">FooBarBaz</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Foo"><span class="annot"><a href="Constrained.Examples.CheatSheet.html#Foo"><span class="hs-identifier hs-var">Foo</span></a></span></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Bar"><span class="annot"><a href="Constrained.Examples.CheatSheet.html#Bar"><span class="hs-identifier hs-var">Bar</span></a></span></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Bool</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="Baz"><span class="annot"><a href="Constrained.Examples.CheatSheet.html#Baz"><span class="hs-identifier hs-var">Baz</span></a></span></span><span> </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679872749"><span id="local-6989586621679872756"><span class="annot"><span class="annottext">FooBarBaz -&gt; FooBarBaz -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: FooBarBaz -&gt; FooBarBaz -&gt; Bool
$c/= :: FooBarBaz -&gt; FooBarBaz -&gt; Bool
== :: FooBarBaz -&gt; FooBarBaz -&gt; Bool
$c== :: FooBarBaz -&gt; FooBarBaz -&gt; Bool
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679872736"><span id="local-6989586621679872738"><span id="local-6989586621679872746"><span class="annot"><span class="annottext">Int -&gt; FooBarBaz -&gt; ShowS
[FooBarBaz] -&gt; ShowS
FooBarBaz -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [FooBarBaz] -&gt; ShowS
$cshowList :: [FooBarBaz] -&gt; ShowS
show :: FooBarBaz -&gt; String
$cshow :: FooBarBaz -&gt; String
showsPrec :: Int -&gt; FooBarBaz -&gt; ShowS
$cshowsPrec :: Int -&gt; FooBarBaz -&gt; ShowS
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></a></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall x. Rep FooBarBaz x -&gt; FooBarBaz
forall x. FooBarBaz -&gt; Rep FooBarBaz x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep FooBarBaz x -&gt; FooBarBaz
$cfrom :: forall x. FooBarBaz -&gt; Rep FooBarBaz x
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-586"></span><span>
</span><span id="line-587"></span><span class="hs-comment">-- All you need to do is introduce instances for `HasSimpleRep` and `HasSpec`:</span><span>
</span><span id="line-588"></span><span>
</span><span id="line-589"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679872728"><span id="local-6989586621679872730"><span class="annot"><a href="Constrained.Base.html#HasSimpleRep"><span class="hs-identifier hs-type">HasSimpleRep</span></a></span><span> </span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#FooBarBaz"><span class="hs-identifier hs-type">FooBarBaz</span></a></span></span></span><span>
</span><span id="line-590"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679872690"><span id="local-6989586621679872692"><span id="local-6989586621679872694"><span id="local-6989586621679872696"><span id="local-6989586621679872698"><span id="local-6989586621679872700"><span id="local-6989586621679872702"><span id="local-6989586621679872704"><span id="local-6989586621679872706"><span id="local-6989586621679872708"><span id="local-6989586621679872710"><span id="local-6989586621679872712"><span id="local-6989586621679872714"><span id="local-6989586621679873993"><span class="annot"><a href="Constrained.Base.html#BaseUniverse"><span class="hs-identifier hs-type">BaseUniverse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679873993"><span class="hs-identifier hs-type">fn</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Constrained.Base.html#HasSpec"><span class="hs-identifier hs-type">HasSpec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679873993"><span class="hs-identifier hs-type">fn</span></a></span><span> </span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#FooBarBaz"><span class="hs-identifier hs-type">FooBarBaz</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-591"></span><span>
</span><span id="line-592"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#fooBarBaz"><span class="hs-identifier hs-type">fooBarBaz</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#FooBarBaz"><span class="hs-identifier hs-type">FooBarBaz</span></a></span><span>
</span><span id="line-593"></span><span id="fooBarBaz"><span class="annot"><span class="annottext">fooBarBaz :: Specification BaseFn FooBarBaz
</span><a href="Constrained.Examples.CheatSheet.html#fooBarBaz"><span class="hs-identifier hs-var hs-var">fooBarBaz</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872674"><span class="annot"><span class="annottext">Term BaseFn FooBarBaz
</span><a href="#local-6989586621679872674"><span class="hs-identifier hs-var">fbb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-594"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, HasSpec fn (SimpleRep a), HasSimpleRep a,
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 SimpleRep a ~ SumOver (Cases (SimpleRep a)),
 TypeList (Cases (SimpleRep a))) =&gt;
Term fn a
-&gt; FunTy
     (MapList (Weighted (Binder fn)) (Cases (SimpleRep a))) (Pred fn)
</span><a href="Constrained.Spec.Generics.html#caseOn"><span class="hs-identifier hs-var">caseOn</span></a></span><span>
</span><span id="line-595"></span><span>    </span><span class="annot"><span class="annottext">Term BaseFn FooBarBaz
</span><a href="#local-6989586621679872674"><span class="hs-identifier hs-var">fbb</span></a></span><span>
</span><span id="line-596"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872673"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872673"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621679872672"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872672"><span class="hs-identifier hs-var">j</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872673"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872672"><span class="hs-identifier hs-var">j</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-597"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872671"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872671"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
BaseUniverse fn =&gt;
Term fn Bool -&gt; Term fn Bool
</span><a href="Constrained.Base.html#not_"><span class="hs-identifier hs-var">not_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Bool
</span><a href="#local-6989586621679872671"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-598"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branch"><span class="hs-identifier hs-var">branch</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  ()
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">False</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-599"></span><span>
</span><span id="line-600"></span><span class="hs-comment">-- &#955;&gt; sample $ genFromSpec fooBarBaz</span><span>
</span><span id="line-601"></span><span class="hs-comment">-- Foo (-1) 0</span><span>
</span><span id="line-602"></span><span class="hs-comment">-- Bar False</span><span>
</span><span id="line-603"></span><span class="hs-comment">-- Foo (-9) (-3)</span><span>
</span><span id="line-604"></span><span class="hs-comment">-- Bar False</span><span>
</span><span id="line-605"></span><span class="hs-comment">-- Foo 1 3</span><span>
</span><span id="line-606"></span><span class="hs-comment">-- Foo (-20) (-8)</span><span>
</span><span id="line-607"></span><span class="hs-comment">-- Foo (-35) (-11)</span><span>
</span><span id="line-608"></span><span class="hs-comment">-- Bar False</span><span>
</span><span id="line-609"></span><span class="hs-comment">-- Foo (-8) 5</span><span>
</span><span id="line-610"></span><span class="hs-comment">-- Bar False</span><span>
</span><span id="line-611"></span><span class="hs-comment">-- Foo (-4) 7</span><span>
</span><span id="line-612"></span><span>
</span><span id="line-613"></span><span class="hs-comment">-- Some functions don't exist on the term level. In this case we can use</span><span>
</span><span id="line-614"></span><span class="hs-comment">-- `reifies :: (HasSpec fn a, HasSpec fn b) =&gt; Term fn b -&gt; Term fn a -&gt; (a -&gt; b) -&gt; Pred fn`</span><span>
</span><span id="line-615"></span><span class="hs-comment">-- to introduce a one-way evaluation of a Haskell function:</span><span>
</span><span id="line-616"></span><span>
</span><span id="line-617"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#reifyExample"><span class="hs-identifier hs-type">reifyExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-618"></span><span id="reifyExample"><span class="annot"><span class="annottext">reifyExample :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#reifyExample"><span class="hs-identifier hs-var hs-var">reifyExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="">[var|a|]</span></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="">[var|b|]</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-619"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn b -&gt; Term fn a -&gt; (a -&gt; b) -&gt; Pred fn
</span><a href="Constrained.Base.html#reifies"><span class="hs-identifier hs-var">reifies</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872668"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872667"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872666"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679872666"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Integral a =&gt; a -&gt; a -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">mod</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679872666"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-620"></span><span>
</span><span id="line-621"></span><span class="hs-comment">-- Here we introduce two variables `a` and `b` without any immediate dependency and we say that</span><span>
</span><span id="line-622"></span><span class="hs-comment">-- `b` reifies `a` via the haskell function `\x -&gt; mod x 10`. The best way to understand what this</span><span>
</span><span id="line-623"></span><span class="hs-comment">-- cryptic code means is to imagine there was a `mod_` function, in that case this code would be equivalent</span><span>
</span><span id="line-624"></span><span class="hs-comment">-- to:</span><span>
</span><span id="line-625"></span><span>
</span><span id="line-626"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#reifyExample%27"><span class="hs-identifier hs-type">reifyExample'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-627"></span><span id="reifyExample%27"><span class="annot"><span class="annottext">reifyExample' :: Specification BaseFn (Int, Int)
</span><a href="Constrained.Examples.CheatSheet.html#reifyExample%27"><span class="hs-identifier hs-var hs-var">reifyExample'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(Cases (SimpleRep a) ~ '[SimpleRep a],
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 HasSpec fn (SimpleRep a), HasSimpleRep a,
 All (HasSpec fn) (Args (SimpleRep a)), IsProd (SimpleRep a),
 HasSpec fn a, IsPred p fn) =&gt;
FunTy (MapList (Term fn) (Args (SimpleRep a))) p
-&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#constrained%27"><span class="hs-identifier hs-var">constrained'</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872663"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872663"><span class="hs-identifier hs-var">a</span></a></span></span><span> </span><span id="local-6989586621679872662"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872662"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-628"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) p.
(BaseUniverse fn, IsPred p fn) =&gt;
p -&gt; Pred fn
</span><a href="Constrained.Base.html#assert"><span class="hs-identifier hs-var">assert</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872662"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3D%3D."><span class="hs-operator hs-var">==.</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ). Term fn Int -&gt; Term fn Int -&gt; Term fn Int
</span><a href="#local-6989586621679872661"><span class="hs-identifier hs-var">mod_</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872663"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">10</span></span><span>
</span><span id="line-629"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872662"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a b.
(HasSpec fn a, HasSpec fn b) =&gt;
Term fn a -&gt; Term fn b -&gt; Pred fn
</span><a href="Constrained.Base.html#dependsOn"><span class="hs-operator hs-var">`dependsOn`</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872663"><span class="hs-identifier hs-var">a</span></a></span><span>
</span><span id="line-630"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-631"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-632"></span><span>    </span><span id="local-6989586621679873903"><span class="annot"><a href="#local-6989586621679872661"><span class="hs-identifier hs-type">mod_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679873903"><span class="hs-identifier hs-type">fn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Constrained.Base.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679873903"><span class="hs-identifier hs-type">fn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Constrained.Base.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679873903"><span class="hs-identifier hs-type">fn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span></span><span>
</span><span id="line-633"></span><span>    </span><span id="local-6989586621679872661"><span class="annot"><span class="annottext">mod_ :: forall (fn :: Univ). Term fn Int -&gt; Term fn Int -&gt; Term fn Int
</span><a href="#local-6989586621679872661"><span class="hs-identifier hs-var hs-var">mod_</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; String -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">error</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;This doesn't exist&quot;</span></span><span>
</span><span id="line-634"></span><span>
</span><span id="line-635"></span><span class="hs-comment">-- When we look at the plan we get from `reifyExample` we get what we'd expect:</span><span>
</span><span id="line-636"></span><span class="hs-comment">-- &#955;&gt; printPlan reifyExample</span><span>
</span><span id="line-637"></span><span class="hs-comment">-- Simplified spec:</span><span>
</span><span id="line-638"></span><span class="hs-comment">--   constrained $ \ v_3 -&gt;</span><span>
</span><span id="line-639"></span><span class="hs-comment">--     let v_1 = Fst (ToGeneric v_3) in</span><span>
</span><span id="line-640"></span><span class="hs-comment">--     let v_0 = Snd (ToGeneric v_3) in reifies v_0 v_1</span><span>
</span><span id="line-641"></span><span class="hs-comment">-- SolverPlan</span><span>
</span><span id="line-642"></span><span class="hs-comment">--   Dependencies:</span><span>
</span><span id="line-643"></span><span class="hs-comment">--     v_0 &lt;- [v_1]</span><span>
</span><span id="line-644"></span><span class="hs-comment">--     v_1 &lt;- []</span><span>
</span><span id="line-645"></span><span class="hs-comment">--     v_3 &lt;- [v_0, v_1]</span><span>
</span><span id="line-646"></span><span class="hs-comment">--   Linearization:</span><span>
</span><span id="line-647"></span><span class="hs-comment">--     v_1 &lt;-</span><span>
</span><span id="line-648"></span><span class="hs-comment">--     v_0 &lt;- reifies v_0 v_1</span><span>
</span><span id="line-649"></span><span class="hs-comment">--     v_3 &lt;-</span><span>
</span><span id="line-650"></span><span class="hs-comment">--       assert $ Equal (Fst (ToGeneric v_3)) v_1</span><span>
</span><span id="line-651"></span><span class="hs-comment">--       assert $ Equal (Snd (ToGeneric v_3)) v_0</span><span>
</span><span id="line-652"></span><span>
</span><span id="line-653"></span><span class="hs-comment">-- Sometimes it is convenient to introduce an auxilliary variable to represent the result of applying the</span><span>
</span><span id="line-654"></span><span class="hs-comment">-- haskell-level function to the term, for this purpose we have</span><span>
</span><span id="line-655"></span><span class="hs-comment">-- `reify :: (HasSpec fn a, HasSpec fn b, IsPred p fn) =&gt; Term fn a -&gt; (a -&gt; b) -&gt; (Term fn b -&gt; p) -&gt; Pred fn`.</span><span>
</span><span id="line-656"></span><span>
</span><span id="line-657"></span><span class="hs-comment">-- We have tools to control the distribution of test cases and monitor those distributions. Using `branchW` we can</span><span>
</span><span id="line-658"></span><span class="hs-comment">-- attach weights to branches in a `caseOn` and using `monitor :: ((forall. Term fn a -&gt; a) -&gt; Property -&gt; Property) -&gt; Pred fn`</span><span>
</span><span id="line-659"></span><span class="hs-comment">-- we can use the normal QuickCheck functions for monitoring distributions of generators to see the effects of this.</span><span>
</span><span id="line-660"></span><span>
</span><span id="line-661"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#monitorExample"><span class="hs-identifier hs-type">monitorExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-662"></span><span id="monitorExample"><span class="annot"><span class="annottext">monitorExample :: Specification BaseFn (Either Int Int)
</span><a href="Constrained.Examples.CheatSheet.html#monitorExample"><span class="hs-identifier hs-var hs-var">monitorExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872656"><span class="annot"><span class="annottext">Term BaseFn (Either Int Int)
</span><a href="#local-6989586621679872656"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-663"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
(HasSpec fn a, HasSpec fn (SimpleRep a), HasSimpleRep a,
 TypeSpec fn a ~ TypeSpec fn (SimpleRep a),
 SimpleRep a ~ SumOver (Cases (SimpleRep a)),
 TypeList (Cases (SimpleRep a))) =&gt;
Term fn a
-&gt; FunTy
     (MapList (Weighted (Binder fn)) (Cases (SimpleRep a))) (Pred fn)
</span><a href="Constrained.Spec.Generics.html#caseOn"><span class="hs-identifier hs-var">caseOn</span></a></span><span>
</span><span id="line-664"></span><span>    </span><span class="annot"><span class="annottext">Term BaseFn (Either Int Int)
</span><a href="#local-6989586621679872656"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-665"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
Int
-&gt; FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branchW"><span class="hs-identifier hs-var">branchW</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
((forall a. Term fn a -&gt; a) -&gt; Property -&gt; Property) -&gt; Pred fn
</span><a href="Constrained.Base.html#monitor"><span class="hs-identifier hs-var">monitor</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">forall b.
Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  b
-&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall prop. Testable prop =&gt; String -&gt; prop -&gt; Property
</span><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-keyword hs-var">label</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Left&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-666"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (fn :: Univ) p a.
(HasSpec fn a, All (HasSpec fn) (Args a), IsPred p fn, IsProd a) =&gt;
Int
-&gt; FunTy (MapList (Term fn) (Args a)) p -&gt; Weighted (Binder fn) a
</span><a href="Constrained.Spec.Generics.html#branchW"><span class="hs-identifier hs-var">branchW</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ).
((forall a. Term fn a -&gt; a) -&gt; Property -&gt; Property) -&gt; Pred fn
</span><a href="Constrained.Base.html#monitor"><span class="hs-identifier hs-var">monitor</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">forall b.
Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  b
-&gt; b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall prop. Testable prop =&gt; String -&gt; prop -&gt; Property
</span><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-keyword hs-var">label</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Right&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-667"></span><span>
</span><span id="line-668"></span><span class="hs-comment">-- The `forAllSpec :: (Testable p, HasSpec fn a) =&gt; Specification fn a -&gt; (a -&gt; p) -&gt; Property` we</span><span>
</span><span id="line-669"></span><span class="hs-comment">-- automatically get the monitoring from the spec in our property:</span><span>
</span><span id="line-670"></span><span>
</span><span id="line-671"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#prop_monitoring"><span class="hs-identifier hs-type">prop_monitoring</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-identifier hs-type">Property</span></a></span><span>
</span><span id="line-672"></span><span id="prop_monitoring"><span class="annot"><span class="annottext">prop_monitoring :: Property
</span><a href="Constrained.Examples.CheatSheet.html#prop_monitoring"><span class="hs-identifier hs-var hs-var">prop_monitoring</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a p.
(HasSpec fn a, Testable p) =&gt;
Specification fn a -&gt; (a -&gt; p) -&gt; Property
</span><a href="Constrained.Properties.html#forAllSpec"><span class="hs-identifier hs-var">forAllSpec</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn (Either Int Int)
</span><a href="Constrained.Examples.CheatSheet.html#monitorExample"><span class="hs-identifier hs-var">monitorExample</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Either Int Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-673"></span><span>
</span><span id="line-674"></span><span class="hs-comment">-- &#955;&gt; quickCheck $ prop_monitoring</span><span>
</span><span id="line-675"></span><span class="hs-comment">-- +++ OK, passed 100 tests:</span><span>
</span><span id="line-676"></span><span class="hs-comment">-- 64% Right</span><span>
</span><span id="line-677"></span><span class="hs-comment">-- 36% Left</span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span class="hs-comment">-- Other tools for controlling distributions of specifications are available too, for example</span><span>
</span><span id="line-680"></span><span class="hs-comment">-- `chooseSpec :: HasSpec fn a =&gt; (Int, Specification fn a) -&gt; (Int, Specification fn a) -&gt; Specification fn a`,</span><span>
</span><span id="line-681"></span><span class="hs-comment">-- the definition of which constitutes a useful object of study to better understand how to use the compositional</span><span>
</span><span id="line-682"></span><span class="hs-comment">-- nature of the system to build powerful features.</span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#chooseSpecExample"><span class="hs-identifier hs-type">chooseSpecExample</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Constrained.Base.html#Specification"><span class="hs-identifier hs-type">Specification</span></a></span><span> </span><span class="annot"><a href="Constrained.Base.html#BaseFn"><span class="hs-identifier hs-type">BaseFn</span></a></span><span> </span><span class="annot"><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-type">Int</span></a></span><span>
</span><span id="line-685"></span><span id="chooseSpecExample"><span class="annot"><span class="annottext">chooseSpecExample :: Specification BaseFn Int
</span><a href="Constrained.Examples.CheatSheet.html#chooseSpecExample"><span class="hs-identifier hs-var hs-var">chooseSpecExample</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-686"></span><span>  </span><span class="annot"><span class="annottext">forall (fn :: Univ) a.
HasSpec fn a =&gt;
(Int, Specification fn a)
-&gt; (Int, Specification fn a) -&gt; Specification fn a
</span><a href="Constrained.Spec.Generics.html#chooseSpec"><span class="hs-identifier hs-var">chooseSpec</span></a></span><span>
</span><span id="line-687"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872649"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872649"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872649"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span>
</span><span id="line-688"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ) p.
(IsPred p fn, HasSpec fn a) =&gt;
(Term fn a -&gt; p) -&gt; Specification fn a
</span><a href="Constrained.Base.html#constrained"><span class="hs-identifier hs-var">constrained</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872648"><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872648"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">forall a (fn :: Univ).
(Ord a, OrdLike fn a) =&gt;
Term fn a -&gt; Term fn a -&gt; Term fn Bool
</span><a href="Constrained.Base.html#%3C."><span class="hs-operator hs-var">&lt;.</span></a></span><span> </span><span class="annot"><span class="annottext">Term
  (Fix
     (Oneof
        (Oneof
           (Oneof MapFn (Oneof PairFn ListFn))
           (Oneof FunFn (Oneof SetFn OrdFn)))
        (Oneof
           (Oneof SumFn (Oneof BoolFn GenericsFn))
           (Oneof SizeFn (Oneof EqFn IntFn)))))
  Int
</span><a href="#local-6989586621679872648"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-689"></span><span>
</span><span id="line-690"></span><span class="annot"><a href="Constrained.Examples.CheatSheet.html#prop_chooseSpec"><span class="hs-identifier hs-type">prop_chooseSpec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-identifier hs-type">Property</span></a></span><span>
</span><span id="line-691"></span><span id="prop_chooseSpec"><span class="annot"><span class="annottext">prop_chooseSpec :: Property
</span><a href="Constrained.Examples.CheatSheet.html#prop_chooseSpec"><span class="hs-identifier hs-var hs-var">prop_chooseSpec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (fn :: Univ) a p.
(HasSpec fn a, Testable p) =&gt;
Specification fn a -&gt; (a -&gt; p) -&gt; Property
</span><a href="Constrained.Properties.html#forAllSpec"><span class="hs-identifier hs-var">forAllSpec</span></a></span><span> </span><span class="annot"><span class="annottext">Specification BaseFn Int
</span><a href="Constrained.Examples.CheatSheet.html#chooseSpecExample"><span class="hs-identifier hs-var">chooseSpecExample</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679872646"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679872646"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-692"></span><span>  </span><span class="annot"><span class="annottext">forall prop. Testable prop =&gt; String -&gt; prop -&gt; Property
</span><a href="../file:///home/runner/.local/state/cabal/store/ghc-9.2.8/QuickCheck-2.15.0.1-4019c8c32cd83e4551b6cacd38479a53d08da5213f8f0afe416c11ef11d8101d/share/doc/html/src"><span class="hs-keyword hs-var">label</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">show</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/base-4.16.4.0/src"><span class="hs-identifier hs-var">signum</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679872646"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../file:///usr/local/.ghcup/ghc/9.2.8/share/doc/ghc-9.2.8/html/libraries/ghc-prim-0.8.0/src"><span class="hs-identifier hs-var">True</span></a></span><span>
</span><span id="line-693"></span><span>
</span><span id="line-694"></span><span class="hs-comment">-- &#955;&gt; quickCheck prop_chooseSpec</span><span>
</span><span id="line-695"></span><span class="hs-comment">-- +++ OK, passed 100 tests:</span><span>
</span><span id="line-696"></span><span class="hs-comment">-- 67% 1</span><span>
</span><span id="line-697"></span><span class="hs-comment">-- 33% -1</span><span>
</span><span id="line-698"></span></pre></body></html>